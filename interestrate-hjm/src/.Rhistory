credit_curve[1,]
credit_curve <- credit_curve[1,]
for (i in 1:nrow(cds_list)) {
#for (i in 1:1) {
#define function
cat("start date:",as.character(cds_list$StartDate[i])," ,end date:",cds_list$EndDate[i]," ,market quote:",cds_list$MarketQuote[i],"\n")
fn_CDS_NPV_Horizon_x <- function(x) { return (CDS_NPV_Horizon(cds_list$StartDate[i],cds_list$EndDate[i],1000000,cds_list$MarketQuote[i],40,discount_curve,credit_curve,x))}
#determine the default spread
ds = as.numeric(dfsane(par=10,fn=fn_CDS_NPV_Horizon_x, method=1,quiet=TRUE)$par)
#add default spread to
nb = nrow(credit_curve)
cat("nrow:",nb,"\n")
credit_curve[nb+1,] = c(as.numeric(cds_list$EndDate[i]-cds_list$StartDate[i]),ds)
cat("Def. Spread:",ds,"\n")
}
View(credit_curve)
View(credit_curve)
cds_list = as.data.frame(matrix(ncol=4, nrow=6))
names(cds_list) = c("StartDate", "EndDate","MarketQuote","DefaultSpread")
cds_list[1,] = c(as.Date("2013-08-31","%Y-%m-%d"), as.Date("2014-03-20","%Y-%m-%d"), 0.110419678, NA)
cds_list[2,] = c(as.Date("2013-08-31","%Y-%m-%d"), as.Date("2014-09-20","%Y-%m-%d"), 0.125449848, NA)
cds_list[3,] = c(as.Date("2013-08-31","%Y-%m-%d"), as.Date("2015-09-20","%Y-%m-%d"), 0.149525394, NA)
cds_list[4,] = c(as.Date("2013-08-31","%Y-%m-%d"), as.Date("2016-09-20","%Y-%m-%d"), 0.230274695, NA)
cds_list[5,] = c(as.Date("2013-08-31","%Y-%m-%d"), as.Date("2017-09-20","%Y-%m-%d"), 0.31773285, NA)
cds_list[6,] = c(as.Date("2013-08-31","%Y-%m-%d"), as.Date("2018-09-20","%Y-%m-%d"), 0.435046288, NA)
cds_list[7,] = c(as.Date("2013-08-31","%Y-%m-%d"), as.Date("2020-09-20","%Y-%m-%d"), 0.645940141, NA)
cds_list[8,] = c(as.Date("2013-08-31","%Y-%m-%d"), as.Date("2020-09-23","%Y-%m-%d"), 0.802699374, NA)
cds_list[9,] = c(as.Date("2013-08-31","%Y-%m-%d"), as.Date("2016-09-28","%Y-%m-%d"), 0.784447513, NA)
cds_list[10,] = c(as.Date("2013-08-31","%Y-%m-%d"), as.Date("2016-09-33","%Y-%m-%d"), 0.785085214, NA)
credit_curve <- credit_curve[1,]
for (i in 1:nrow(cds_list)) {
#for (i in 1:1) {
#define function
cat("start date:",as.character(cds_list$StartDate[i])," ,end date:",cds_list$EndDate[i]," ,market quote:",cds_list$MarketQuote[i],"\n")
fn_CDS_NPV_Horizon_x <- function(x) { return (CDS_NPV_Horizon(cds_list$StartDate[i],cds_list$EndDate[i],1000000,cds_list$MarketQuote[i],40,discount_curve,credit_curve,x))}
#determine the default spread
ds = as.numeric(dfsane(par=10,fn=fn_CDS_NPV_Horizon_x, method=1,quiet=TRUE)$par)
#add default spread to
nb = nrow(credit_curve)
cat("nrow:",nb,"\n")
credit_curve[nb+1,] = c(as.numeric(cds_list$EndDate[i]-cds_list$StartDate[i]),ds)
cat("Def. Spread:",ds,"\n")
}
credit_curve <- credit_curve[1,]
for (i in 1:nrow(cds_list)) {
#for (i in 1:1) {
#define function
cat("start date:",as.character(cds_list$StartDate[i])," ,end date:",cds_list$EndDate[i]," ,market quote:",cds_list$MarketQuote[i])
fn_CDS_NPV_Horizon_x <- function(x) { return (CDS_NPV_Horizon(cds_list$StartDate[i],cds_list$EndDate[i],1000000,cds_list$MarketQuote[i],40,discount_curve,credit_curve,x))}
#determine the default spread
ds = as.numeric(dfsane(par=10,fn=fn_CDS_NPV_Horizon_x, method=1,quiet=TRUE)$par)
#add default spread to
nb = nrow(credit_curve)
#cat("nrow:",nb,"\n")
credit_curve[nb+1,] = c(as.numeric(cds_list$EndDate[i]-cds_list$StartDate[i]),ds)
cat(" ,Def. Spread:",ds,"\n")
}
credit_curve <- credit_curve[1,]
for (i in 1:nrow(cds_list)) {
#for (i in 1:1) {
#define function
cat("start date:",as.character(cds_list$StartDate[i])," ,end date:",cds_list$EndDate[i]," ,market quote:",cds_list$MarketQuote[i], " ")
fn_CDS_NPV_Horizon_x <- function(x) { return (CDS_NPV_Horizon(cds_list$StartDate[i],cds_list$EndDate[i],1000000,cds_list$MarketQuote[i],40,discount_curve,credit_curve,x))}
#determine the default spread
ds = as.numeric(dfsane(par=10,fn=fn_CDS_NPV_Horizon_x, method=1,quiet=TRUE)$par)
#add default spread to
nb = nrow(credit_curve)
#cat("nrow:",nb,"\n")
credit_curve[nb+1,] = c(as.numeric(cds_list$EndDate[i]-cds_list$StartDate[i]),ds)
cat(" ,Def. Spread:",ds,"\n")
}
View(cds_list)
assetSPX <- read.delim("clipboard")
View(assetSPX)
View(assetSPX)
size(assetSPX)
dim(assetSPX)
dim(assetSPX)[0]
dim(assetSPX)[1]
assetSPX[0]
assetSPX[1]
assetSPX[1][1]
assetSPX[1,1][1]
assetSPX[1,1]
assetSPX#Date
View(assetSPX)
View(assetSPX)
assetSPX$Close
assetSPX$Close[1]
returns.frame = as.data.frame(matrix(ncol=1, nrow=dim(assetSPX)[1]))
names(returns.frame) = c("Return")
assetSPX$Close[16107]
assetSPX$Close[16108]
names(returns.frame) = c("Return")
for (i in 1:(nrow=dim(assetSPX)[1]-1))
{
returns.frame$Return = (assetSPX$Close[i+1]-assetSPX$Close[i])/assetSPX$Close[i];
}
View(returns.frame)
View(returns.frame)
mean(returns.frame$Return)
average(returns.frame$Return)
returns.frame$Return
dim(returns.frame$Return)
mean(returns.frame$Return)
returns.frame = as.data.frame(matrix(ncol=1, nrow=dim(assetSPX)[1]-1))
names(returns.frame) = c("Return")
for (i in 1:(nrow=dim(assetSPX)[1]-1))
{
returns.frame$Return[i] = (assetSPX$Close[i+1]-assetSPX$Close[i])/assetSPX$Close[i];
}
View(returns.frame)
View(returns.frame)
mu = mean(returns.frame$Return)
signma = sd(returns.frame$Return)
mod(10)
mod(10,2)
10 mod 2
10 %% 2
11 %% 2
nb_items = dim(returns.frame)[1] / 2
nb_items = round(dim(returns.frame)[1] / 2, digits = 0)
nb_items_even = round(dim(returns.frame)[1] / 2, digits = 0)
returns_even.frame = as.data.frame(matrix(ncol=1, nrow=nb_items_even))
names(returns_even.frame) = c("Return")
for (i in 1:(nrow=dim(returns_even.frame)[1]))
{
returns_even.frame$Return[i] = returns.frame$Return[2*i];
}
View(returns_even.frame)
View(returns.frame)
returns_even.frame$Return[8053]
returns_even.frame$Return[8054]
returns.frame$Return[16106]
returns.frame$Return[10000]
returns_even.frame$Return[5000]
mu_even = mean(returns_even.frame$Return)
signma_even = sd(returns_even.frame$Return)
nb_items_odd = round(dim(returns.frame)[1] / 2, digits = 0)
returns_odd.frame = as.data.frame(matrix(ncol=1, nrow=nb_items_odd))
names(returns_odd.frame) = c("Return")
for (i in 1:(nrow=dim(returns_odd.frame)[1]))
{
returns_odd.frame$Return[i] = returns.frame$Return[2*(i-1)+1];
}
returns_odd.frame$Return[1]
returns.frame$Return[1]
returns_odd.frame$Return[2]
returns.frame$Return[3]
returns_odd.frame$Return[1000]
returns.frame$Return[1999]
mu_odd = mean(returns_odd.frame$Return)
signma_odd = sd(returns_odd.frame$Return)
min = min(returns.frame$Return)
max = max(returns.frame$Return)
returns_scale.frame = as.data.frame(dim(returns.frame)[1])
names(returns_scale.frame) = c("Return")
returns.frame$Return-mu
(returns.frame$Return-mu)/sigma
sigma = sd(returns.frame$Return)
(returns.frame$Return-mu)/sigma
returns_scale.frame$Return = (returns.frame$Return-mu)/sigma
for (i in 1:(dim(returns_scale.frame)[1])
{
returns_scale.frame$Return[i] = (returns.frame$Return[i]-mu)/sigma;
}
for (i in 1:(dim(returns_scale.frame)[1]))
{
returns_scale.frame$Return[i] = (returns.frame$Return[i]-mu)/sigma;
}
mean(returns_scale.frame$Return)
sd(returns_scale.frame$Return)
returns_scale.frame$Return
returns_scale.frame = as.data.frame(dim(returns.frame)[1])
names(returns_scale.frame) = c("Return")
View(returns_scale.frame)
dim(returns.frame)[1]
returns_scale.frame = as.data.frame(matrix(ncol=1, dim(returns.frame)[1])
View(returns_scale.frame)
View(returns_scale.frame)
View(returns_scale.frame)
returns_scale.frame = as.data.frame(matrix(ncol=1, dim(returns.frame)[1]))
returns_scale.frame
returns_scale.frame = as.data.frame(matrix(ncol=1, dim(returns.frame)[1]))
names(returns_scale.frame) = c("Return")
for (i in 1:(dim(returns_scale.frame)[1]))
{
returns_scale.frame$Return[i] = (returns.frame$Return[i]-mu)/sigma;
}
returns_scale.frame
View(returns_scale.frame)
returns_scale.frame = as.data.frame(matrix(ncol=1, 5))
returns_scale.frame = as.data.frame(matrix(ncol=1, nrow=dim(returns.frame)[1]))
names(returns_scale.frame) = c("Return")
#returns_scale.frame$Return = (returns.frame$Return-mu)/sigma
for (i in 1:(dim(returns_scale.frame)[1]))
{
returns_scale.frame$Return[i] = (returns.frame$Return[i]-mu)/sigma;
}
View(returns_scale.frame)
mu_scaled = mean(returns_scale.frame$Return)
sigma_scaled = sd(returns_scale.frame$Return)
returns_scale.frame
sort(returns_scale.frame)
returns_scale.frame[order (returns_scale.frame$Return)]
returns_scale.frame[order(returns_scale.frame$Return)]
order(returns_scale.frame$Return)
Y = order(returns_scale.frame$Return)
fix(Y)
returns_scale.frame$Return
order(returns_scale.frame$Return)
order(returns_scale.frame$Return, decreasing=TRUE)
order(returns_scale.frame$Return, decreasing=TRUE)
min(returns_scale.frame$Return)
max(returns_scale.frame$Return)
order(returns_scale.frame$Return)
order(returns_scale.frame$Return)[1]
View(returns_scale.frame)
View(returns_scale.frame)
order(returns_scale.frame$Return)[16107]
order(returns_scale.frame$Return)[16106]
returns_scale[order(returns_scale.frame$Return)]
returns_scale
returns_scale.frame
returns_scale.frame[order(returns_scale.frame$Return)]
returns_scale.frame$Return[order(returns_scale.frame$Return)]
returns_scale.frame$Return[order(returns_scale.frame$Return)]
returns_scale.frame$Return[order(returns_scale.frame$Return)][1]
returns_scale.frame$Return[order(returns_scale.frame$Return)][16106]
Y = returns_scale.frame$Return[order(returns_scale.frame$Return)]
mu = matrix(c(0.05,0.07,0.15,0.27), nrow=4, ncol=1, byrow=TRUE)
sigma = matrix(c(0.07,0.12,0.30,0.60), nrow=4, ncol=1, byrow=TRUE)
S = matrix(
c(sigma[1,],0,0,0,
0, sigma[2,],0,0,
0,0,sigma[3,],0,
0,0,0,sigma[4,]), nrow=4, ncol=4, byrow=TRUE)
R = matrix(
c(1.0,0.8,0.5,0.4,
0.8,1.0,0.7,0.5,
0.5,0.7,1.0,0.8,
0.4,0.5,0.8,1.0), nrow=4, ncol=4, byrow=TRUE)
CovarianceMatrix = S %*% R %*% S
expected_return = 0.1
fr = function(X) {
Weights = matrix(head(X,n=4), nrow=4, ncol=1, byrow=TRUE);
Uno = matrix(c(1,1,1,1), nrow=4, ncol=1, byrow=TRUE);
lambda1 = X[5];
lambda2 = X[6];
val = 0.5 * t(Weights) %*% (S %*% R %*% S) %*% Weights + lambda1 * (1- t(Uno) %*% Weights) + lambda2 * (expected_return - t(mu) %*% Weights)
return(val)
}
optim(c(0.25,0.25,0.25,0.25,1,1),fn=fr,gr = NULL,method = c("Nelder-Mead"),
lower = -Inf, upper = Inf,control = list(), hessian = T)
fr(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513))
fr(c(0.25,0.25,0.25,0.25,1,1))
fr(c(0.25,0.25,0.25,0.25,10,10))
optim(c(0.25,0.25,0.25,0.25,1,1),fn=fr,gr = NULL,method = c("SANN"),
lower = -Inf, upper = Inf,control = list(), hessian = T)
optim(c(0.25,0.25,0.25,0.25,1,1),fn=fr,gr = NULL,method = c("SANN"),
lower = -Inf, upper = Inf,control = list(), hessian = T)
optim(c(0.25,0.25,0.25,0.25,1,1),fn=fr,gr = NULL,method = c("Nelder-Mead"),
lower = -Inf, upper = Inf,control = list(), hessian = T)
optim(c(0.25,0.25,0.25,0.25,1,1),fn=fr,gr = NULL,method = c("BFGS"),
lower = -Inf, upper = Inf,control = list(), hessian = T)
fr(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513))
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513),fn=fr,gr = NULL,method = c("BFGS"),
lower = -Inf, upper = Inf,control = list(), hessian = T)
fr = function(X) {
Weights = matrix(head(X,n=4), nrow=4, ncol=1, byrow=TRUE);
Uno = matrix(c(1,1,1,1), nrow=4, ncol=1, byrow=TRUE);
lambda1 = X[5];
lambda2 = X[6];
val = 0.5 * t(Weights) %*% (S %*% R %*% S) %*% Weights - lambda1 * (1 - t(Uno) %*% Weights) - lambda2 * (expected_return - t(mu) %*% Weights)
return(val)
}
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513),fn=fr,gr = NULL,method = c("BFGS"),
lower = -Inf, upper = Inf,control = list(), hessian = T)
fr = function(X) {
Weights = matrix(head(X,n=4), nrow=4, ncol=1, byrow=TRUE);
Uno = matrix(c(1,1,1,1), nrow=4, ncol=1, byrow=TRUE);
lambda1 = X[5];
lambda2 = X[6];
val = 0.5 * t(Weights) %*% (S %*% R %*% S) %*% Weights + lambda1 * (1 - t(Uno) %*% Weights) + lambda2 * (expected_return - t(mu) %*% Weights)
return(val)
}
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513),fn=fr,gr = NULL,method = c("BFGS"),
lower = -Inf, upper = Inf,control = list(fnscale = -1), hessian = T)
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513),fn=fr,gr = NULL,method = c("BFGS"),
lower = -Inf, upper = Inf,control = list(fnscale = -1), hessian = T)
fr = function(X) {
Weights = matrix(head(X,n=4), nrow=4, ncol=1, byrow=TRUE);
Uno = matrix(c(1,1,1,1), nrow=4, ncol=1, byrow=TRUE);
#lambda1 = X[5];
lamda1 = -0.0105013;
lambda2 = 0.3652794;
#lambda2 = X[6];
val = 0.5 * t(Weights) %*% (S %*% R %*% S) %*% Weights + lambda1 * (1 - t(Uno) %*% Weights) + lambda2 * (expected_return - t(mu) %*% Weights)
return(val)
}
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513),fn=fr,gr = NULL,method = c("BFGS"),
lower = -Inf, upper = Inf,control = list(fnscale = -1), hessian = T)
fr = function(X) {
Weights = matrix(head(X,n=4), nrow=4, ncol=1, byrow=TRUE);
Uno = matrix(c(1,1,1,1), nrow=4, ncol=1, byrow=TRUE);
#lambda1 = X[5];
lambda1 = -0.0105013;
lambda2 = 0.3652794;
#lambda2 = X[6];
val = 0.5 * t(Weights) %*% (S %*% R %*% S) %*% Weights + lambda1 * (1 - t(Uno) %*% Weights) + lambda2 * (expected_return - t(mu) %*% Weights)
return(val)
}
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513),fn=fr,gr = NULL,method = c("BFGS"),
lower = -Inf, upper = Inf,control = list(fnscale = -1), hessian = T)
#require(ggplot2)
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513),fn=fr,gr = NULL,method = c("BFGS"),
lower = -Inf, upper = Inf,control = list(fnscale = -1), hessian = T)
mu = matrix(c(0.05,0.07,0.15,0.27), nrow=4, ncol=1, byrow=TRUE)
sigma = matrix(c(0.07,0.12,0.30,0.60), nrow=4, ncol=1, byrow=TRUE)
S = matrix(
c(sigma[1,],0,0,0,
0, sigma[2,],0,0,
0,0,sigma[3,],0,
0,0,0,sigma[4,]), nrow=4, ncol=4, byrow=TRUE)
R = matrix(
c(1.0,0.8,0.5,0.4,
0.8,1.0,0.7,0.5,
0.5,0.7,1.0,0.8,
0.4,0.5,0.8,1.0), nrow=4, ncol=4, byrow=TRUE)
CovarianceMatrix = S %*% R %*% S
expected_return = 0.1
fr = function(X) {
Weights = matrix(head(X,n=4), nrow=4, ncol=1, byrow=TRUE);
Uno = matrix(c(1,1,1,1), nrow=4, ncol=1, byrow=TRUE);
#lambda1 = X[5];
lambda1 = -0.0105013;
lambda2 = 0.3652794;
#lambda2 = X[6];
val = 0.5 * t(Weights) %*% (S %*% R %*% S) %*% Weights + lambda1 * (1 - t(Uno) %*% Weights) + lambda2 * (expected_return - t(mu) %*% Weights)
return(val)
}
fr(c(0,0,0,0,0,0))
fr(c(0,0,0,0,0,0))
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513),fn=fr,gr = NULL,method = c("BFGS"),
lower = -Inf, upper = Inf,control = list(fnscale = -1), hessian = T)
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513),fn=fr,gr = NULL,method = c("BFGS"),
lower = 0.001, upper = Inf,control = list(fnscale = -1), hessian = T)
NULL,method = c("L-BFGS-B"),
lower = 0.001, upper = Inf,control = list(fnscale = -1), hessian = T)
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513),fn=fr,gr = NULL,method = c("L-BFGS-B"),
lower = c(0.001), upper = Inf,control = list(fnscale = -1), hessian = T)
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513),fn=fr,gr = NULL,method = c("L-BFGS-B"),
lower = c(-Inf,-Inf,-Inf,-Inf,0.00001,0.00001), upper = Inf,control = list(fnscale = -1), hessian = T)
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513),fn=fr,gr = NULL,method = c("L-BFGS-B"),
lower = c(-Inf,-Inf,-Inf,-Inf,0.00001,0.00001), upper = Inf,control = list(fnscale = -1), hessian = T)
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.3652794,-0.010513),fn=fr,gr = NULL,method = c("L-BFGS-B"),
lower = c(-Inf,-Inf,-Inf,-Inf,0.00001,-0.00001), upper = Inf,control = list(fnscale = -1), hessian = T)
optim(c(0.25,0.25,0.25,0.25,1,1),fn=fr,gr = NULL,method = c("L-BFGS-B"),
lower = c(-Inf,-Inf,-Inf,-Inf,-1,-1), upper = Inf,control = list(fnscale = -1), hessian = T)
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,1,1),fn=fr,gr = NULL,method = c("L-BFGS-B"),
lower = c(-Inf,-Inf,-Inf,-Inf,-1,-1), upper = Inf,control = list(fnscale = -1), hessian = T)
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.5,0.5),fn=fr,gr = NULL,method = c("L-BFGS-B"),
lower = c(-Inf,-Inf,-Inf,-Inf,-1,-1), upper = Inf,control = list(fnscale = -1), hessian = T)
abs(-2)
fr = function(X) {
Weights = matrix(head(X,n=4), nrow=4, ncol=1, byrow=TRUE);
Uno = matrix(c(1,1,1,1), nrow=4, ncol=1, byrow=TRUE);
lambda1 = X[5];
#lambda1 = -0.0105013;
lambda2 = X[6];
#lambda2 = 0.3652794;
val = 0.5 * t(Weights) %*% (S %*% R %*% S) %*% Weights + lambda1 * (1 - t(Uno) %*% Weights) + lambda2 * (expected_return - t(mu) %*% Weights)
if (abs(lambda1) < 0.01 ) val = val + lambda1 * 10^15;
if (abs(lambda2) < 0.01 ) val = val + lambda2 * 10^15;
return(val)
}
fr(c(0,0,0,0,0,0))
fr(c(0,0,0,0,0,0))
fr = function(X) {
Weights = matrix(head(X,n=4), nrow=4, ncol=1, byrow=TRUE);
Uno = matrix(c(1,1,1,1), nrow=4, ncol=1, byrow=TRUE);
lambda1 = X[5];
#lambda1 = -0.0105013;
lambda2 = X[6];
#lambda2 = 0.3652794;
val = 0.5 * t(Weights) %*% (S %*% R %*% S) %*% Weights + lambda1 * (1 - t(Uno) %*% Weights) + lambda2 * (expected_return - t(mu) %*% Weights)
if (abs(lambda1) < 0.01 ) val = val + 10^15;
if (abs(lambda2) < 0.01 ) val = val + 10^15;
return(val)
}
fr(c(0,0,0,0,0,0))
optim(c(0.25,0.25,0.25,0.25,0.5,0.5),fn=fr,gr = NULL,method = c("L-BFGS-B"),
lower = c(-Inf,-Inf,-Inf,-Inf,-1,-1), upper = Inf,control = list(fnscale = -1), hessian = T)
# Optimization problem with many extrema: non-linear regression
#   y = sin( a * x + b ) + noise
n <- 100
x <- seq(0,1,length=n)
f <- function(x,a,b) sin(a*x+b)
y <- f(x, 4*pi*runif(1), 2*pi*runif(1)) + rnorm(n)
g <- function(a,b) sum((f(x,a,b) - y)^2)
N <- 200
a <- seq(0, 10*pi, length=N)
b <- seq(0,  2*pi, length=N)
z <- outer(a, b, Vectorize(g))
image(a, b, z,
las=1,
main="Multiple extrema",
xlab="Frequency",
ylab="Phase"
)
# Compute the extrema visible on the plot
shift <- function(z,i,j) {
n <- nrow(z)
m <- ncol(z)
u <- NA * z
if(i >= 0  && j >= 0) { u[1:(n-i),  1:(m-j)] <- z[(i+1):n, (j+1):m]
} else if(i <= 0  && j >= 0) { u[(-i+1):n, 1:(m-j)] <- z[1:(n+i), (j+1):m]
} else if(i >= 0  && j <= 0) { u[1:(n-i), (-j+1):m] <- z[(i+1):n, 1:(m+j)]
} else if(i <= 0  && j <= 0) { u[(-i+1):n,(-j+1):m] <- z[1:(n+i), 1:(m+j)]
}
u
}
u <- v <- z == z
for(i in c(-1,0,1))
for(j in c(-1,0,1))
if(abs(i)+abs(j)>0) {
tmp <- shift(z,i,j)
u <- u & z >= tmp
v <- v & z <= tmp
}
v <- which(v, arr.ind=TRUE )
v <- t(apply(v,1,function(u) c(a[u[1]], b[u[2]])))
v <- t(apply(v, 1, function(r) optim(r, function(p) g(p[1],p[2]))$par))
points(v, pch="+", cex=2)
u <- which(u, arr.ind=TRUE )
u <- t(apply(u,1,function(u) c(a[u[1]], b[u[2]])))
u <- t(apply(u, 1, function(r) optim(r, function(p) -g(p[1],p[2]))$par))
points(u, pch="-", cex=2)
# Not much to see on the 3D plot
library(rgl)
persp3d(a,b,z
optim(c(0.25,0.25,0.25,0.25,0.5,0.5),fn=fr,gr = NULL,method = c("L-BFGS-B"),
lower = c(-Inf,-Inf,-Inf,-Inf,-1,-1), upper = Inf,control = list(maxit=100), hessian = T)
optim(c(0.25,0.25,0.25,0.25,0.5,0.5),fn=fr,gr = NULL,method = c("L-BFGS-B"),
lower = c(-Inf,-Inf,-Inf,-Inf,-1,-1), upper = Inf,control = list(maxit=100), hessian = T)
optim(c(0.25,0.25,0.25,0.25,0.5,0.5),fn=fr,gr = NULL,method = c("L-BFGS-B"),
lower = c(-Inf,-Inf,-Inf,-Inf,-Inf,-Inf), upper = c(Inf,Inf,Inf,Inf,Inf,Inf),control = list(maxit=100), hessian = T)
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.5,0.5),fn=fr,gr = NULL,method = c("L-BFGS-B"),
lower = c(-Inf,-Inf,-Inf,-Inf,-Inf,-Inf), upper = c(Inf,Inf,Inf,Inf,Inf,Inf),control = list(maxit=100), hessian = T)
optim(c(0.528412108,0.172888075,0.159764343,0.138935474,0.5,0.5),fn=fr,gr = NULL,method = c("L-BFGS-B"),
lower = c(-Inf,-Inf,-Inf,-Inf,0.01,-Inf), upper = c(Inf,Inf,Inf,Inf,Inf,Inf),control = list(maxit=100), hessian = T)
require("quantmod")
install.packages("quantmod")
require("quantmod")
DJIA201212 <- c("AA", "AXP", "BA", "BAC", "CAT", "CSCO", "CVX", "DD", "DIS",
"GE", "HD", "HPQ", "IBM", "INTC", "JNJ", "JPM", "KO", "MCD", "MMM", "MRK", "MSFT", "PFE", "PG", "T", "TRV", "UNH", "UTX", "VZ", "WMT", "XOM")
# select ticker symbols and time frame
stocks <- DJIA201212
date_begin <- as.Date("2012-01-01")
date_end <- as.Date("2012-12-31")
tickers <- getSymbols(stocks, from = date_begin, to = date_end, auto.assign = TRUE)
tickers
# combine the adjusted close values in one (xts) data.frame
dataset <- Ad(get(tickers[1]))
for (i in 2:length(tickers)) {
dataset <- merge(dataset, Ad(get(tickers[i])))
}
dataset
# handle NA values (four common alternatives)
data_omit <- na.omit(dataset)  # omit values with NA values
data_locf <- na.locf(dataset)  # last observation carried forward
data_approx <- na.approx(dataset)  # linear approximation
data_spline <- na.spline(dataset)  # cubic spline interpolation
# calculate returns
return_lag <- 5  # (crude) weekly returns
data <- na.omit(ROC(data_spline, return_lag, type = "discrete"))
names(data) <- stocks
data
head(data)
tail(data)
head(data)
# save data as RData
save(data, file = "djia2012w.rda")
install.packages("financeR")
require("financeR")
require("financeR")
require("xts")
require("tseries")
install.packages("tseries")
install.packages("xts")
require("xts")
require("tseries")
# load a prepared scenario set from package financeR
data(djia2012w)
data(djia2012w.rda)
djia2012w
save(data, file = "D:\temp\djia2012w.rda")
#clear workspace
rm(list = ls())
#variables
current_dir = "P:/CQF/FinalProject/git-root/finalproject/interestrate-hjm/src"
#End of variables
print("Program starting...")
#set current directory
setwd(current_dir)
source("class_definition.R") # define classes
#install / load dependencies
source("install_register_packages.R")
#source("class_definition.R") # define classes
#historical data loading, cleaning. Credit Curve Construction
source("market_data_functions.R")
source("market_data_loading.R")
